#include <iostream>
#include <Windows.h>
#include <time.h>
#include <ctime>
#include <chrono>
#include <thread>
#include <math.h>
#include <cstdlib>
#include <cctype>
#include <string>
#include <sstream>
#include <unordered_map>
#include <fstream>
#include <cstring>
#pragma warning(disable : 4996)
using namespace std;
using namespace chrono;
int promptMenuItem()
{

    int variant;
    cout << "Выберите вариант: " << endl;
    cout << "1. Создать несортированный массив из 100 элементов\n"
        << "2. Отсортировать заданный в пункте 1 массив\n"
        << "3. Найти максимальный и минимальный элемент\n"
        << "4. Найти средний элемент\n"
        << "5. Вывести количество элементов в отсортированном массиве, которые меньше числа num\n"
        << "6. Вывести количество элементов в отсортированном массиве, которые больше числа num\n"
        << "7. Бинарный поиск\n"
        << "8. Смена элементов массива\n"
        << "9. Shellsort" << endl;
    cout << ">>> ";
    cin >> variant;
    return variant;
}
void preprocessBadChar(const char* pattern, unordered_map<char, int>& badChar) {
    int patternLength = strlen(pattern);
    for (int i = 0; i < patternLength; i++) {
        badChar[pattern[i]] = i;
    }
}

void boyerMooreSearch(const char* text, const char* pattern) {
    int textLength = strlen(text);
    int patternLength = strlen(pattern);
    unordered_map<char, int> badChar;

    preprocessBadChar(pattern, badChar);

    int shift = 0;
    while (shift <= textLength - patternLength) {
        int j = patternLength - 1;

        while (j >= 0 && pattern[j] == text[shift + j]) {
            j--;
        }

        if (j < 0) {
            cout << "Найдено в позиции: " << shift << endl;
            shift += (shift + patternLength < textLength) ? patternLength - badChar[text[shift + patternLength]] : 1;
        }
        else {
            shift += max(1, j - badChar[text[shift + j]]);
        }
    }
}

void removeExtraSpaces(char* inputText) {
    char temp[1000];
    int j = 0;

    bool inSpace = false;

    for (int i = 0; inputText[i] != '\0'; ++i) {
        if (inputText[i] != ' ') {
            temp[j++] = inputText[i];
            inSpace = false;
        }
        else if (!inSpace) {
            temp[j++] = ' ';
            inSpace = true;
        }
    }
    temp[j] = '\0';

    strcpy(inputText, temp);
}

void removeExtraPunctuation(char* inputText) {
    char temp[1000];
    int j = 0;

    for (int i = 0; inputText[i] != '\0'; ++i) {
        if (ispunct(inputText[i])) {
            if (i == 0 || !ispunct(inputText[i - 1])) {
                temp[j++] = inputText[i];
            }
        }
        else {
            temp[j++] = inputText[i];
        }
    }
    temp[j] = '\0';

    strcpy(inputText, temp);
}
void correctCase(char* inputText) {
    bool newSentence = true;

    for (int i = 0; inputText[i] != '\0'; ++i) {
        if (newSentence && isalpha(inputText[i])) {
            inputText[i] = toupper(inputText[i]);
            newSentence = false;
        }
        else {
            inputText[i] = tolower(inputText[i]);
        }

        if (inputText[i] == '.' || inputText[i] == '!' || inputText[i] == '?') {
            newSentence = true;
        }
    }
}
void editText(char* inputText) {
    removeExtraSpaces(inputText);
    removeExtraPunctuation(inputText);
    correctCase(inputText);
}
void linearSearch(const char* text, const char* pattern) {
    int textLength = strlen(text);
    int patternLength = strlen(pattern);

    for (int i = 0; i <= textLength - patternLength; i++) {
        int j;
        for (j = 0; j < patternLength; j++) {
            if (text[i + j] != pattern[j]) {
                break;
            }
        }
        if (j == patternLength) {
            cout << "Найдено в позиции: " << i << endl;
        }
    }
}

void quicksort(int* arr, int  end, int begin)
{
    int mid;
    int f = begin;
    int l = end;
    mid = arr[(f + l) / 2];
    while (f < l)
    {
        while (arr[f] < mid) f++;
        while (arr[l] > mid) l--;
        if (f <= l)
        {
            swap(arr[f], arr[l]);
            f++;
            l--;
        }
    }
    if (begin < l) quicksort(arr, l, begin);
    if (f < end) quicksort(arr, end, f);
}
int binarySearch(int arr[], int value, int start, int end) {
    if (end >= start) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == value) {
            return mid;
        }
        if (arr[mid] > value) {
            return binarySearch(arr, value, start, mid - 1);
        }
        return binarySearch(arr, value, mid + 1, end);
    }
    return -1;
}
int shellSort(int arr[], int n) {
    for (int interval = n / 2; interval > 0; interval /= 2) {
        for (int i = interval; i < n; i += 1) {
            int temp = arr[i];
            int j;
            for (j = i; j >= interval && arr[j - interval] > temp; j -= interval) {
                arr[j] = arr[j - interval];
            }
            arr[j] = temp;
        }
    }
    return 0;
}
int taskMenu()
{
    int variant;
    cout << "Выберите задание: " << endl;
    cout << "1) Вывести матрицу N*N\n"
        << "2) Перестановки матриц\n"
        << "3) Сортировка(shaker sort)\n"
        << "4) Уменьшение, увеличение, умножение или деление всех элементов матрицы на введенное пользователем число\n"
        << "5) IDZ" << endl;
    cout << "Задание: ";
    cin >> variant;
    return variant;
}

int const N = 6;

void ANACONDAoutput(int (*arr)[N]) {
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD destCoord;
    int top = 0, bottom = N - 1;
    int left = 0, right = N - 1;
    while (top <= bottom && left <= right) {
        for (int i = left; i <= right; i++) {
            destCoord.X = i * 3;
            destCoord.Y = top;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << *(*(arr + top) + i) << " ";
            Sleep(50);
        }
        top++;
        for (int i = top; i <= bottom; i++) {
            destCoord.X = right * 3;
            destCoord.Y = i;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << *(*(arr + i) + right) << " ";
            Sleep(50);
        }
        right--;

        if (top <= bottom) {
            for (int i = right; i >= left; i--) {
                destCoord.X = i * 3;
                destCoord.Y = bottom;
                SetConsoleCursorPosition(hStdout, destCoord);
                cout << *(*(arr + bottom) + i) << " ";
                Sleep(50);
            }
            bottom--;
        }

        if (left <= right) {
            for (int i = bottom; i >= top; i--) {
                destCoord.X = left * 3;
                destCoord.Y = i;
                SetConsoleCursorPosition(hStdout, destCoord);
                cout << *(*(arr + i) + left) << " ";
                Sleep(50);
            }
            left++;
        }
    }

    destCoord.X = 0;
    destCoord.Y = N + 1;
    SetConsoleCursorPosition(hStdout, destCoord);
}
void ANACONDAoutput2(int (*arr)[N]) {
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD destCoord;

    // Начальные границы
    int top = N / 2;
    int bottom = N / 2;
    int left = N / 2;
    int right = N / 2;

    // Общее количество элементов
    int totalElements = N * N;
    int count = 0;

    while (count < totalElements) {
        // Двигаемся вправо
        for (int i = left; i <= right && count < totalElements; i++) {
            destCoord.X = i * 3;
            destCoord.Y = top;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << arr[top][i] << " ";
            count++;
            Sleep(50);
        }
        top--; // Сдвигаем верхнюю границу вниз

        // Двигаемся вниз
        for (int i = top; i <= bottom && count < totalElements; i++) {
            destCoord.X = right * 3;
            destCoord.Y = i;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << arr[i][right] << " ";
            count++;
            Sleep(50);
        }
        right++; // Сдвигаем правую границу влево

        // Двигаемся влево
        for (int i = right; i >= left && count < totalElements; i--) {
            destCoord.X = i * 3;
            destCoord.Y = bottom;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << arr[bottom][i] << " ";
            count++;
            Sleep(50);
        }
        bottom++; // Сдвигаем нижнюю границу вверх

        // Двигаемся вверх
        for (int i = bottom; i >= top && count < totalElements; i--) {
            destCoord.X = left * 3;
            destCoord.Y = i;
            SetConsoleCursorPosition(hStdout, destCoord);
            cout << arr[i][left] << " ";
            count++;
            Sleep(50);
        }
        left--; // Сдвигаем левую границу вправо
    }

    // Перемещаем курсор в конец вывода
    destCoord.X = 0;
    destCoord.Y = N + 1;
    SetConsoleCursorPosition(hStdout, destCoord);
}
void quicksort(int* begin, int* end) {
    if (begin >= end) return;

    int* f = begin;
    int* l = end;
    int mid = *(f + (l - f) / 2);

    while (f <= l) {
        while (*f < mid) f++;
        while (*l > mid) l--;
        if (f <= l) {
            swap(*f, *l);
            f++;
            l--;
        }
    }
    if (begin < l) quicksort(begin, l);
    if (f < end) quicksort(f, end);
}
void PITONoutput(int (*arr)[N]) {
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD destCoord;

    for (int stolb = 0; stolb < N; stolb++) {
        if (stolb % 2 == 0) {
            for (int row = 0; row < N; row++) {
                destCoord.X = (N * N) + (stolb * 3);
                destCoord.Y = row;
                SetConsoleCursorPosition(hStdout, destCoord);
                cout << *(*(arr + row) + stolb) << " ";
                Sleep(50);
            }
        }
        else {
            for (int row = N - 1; row >= 0; row--) {
                destCoord.X = (N * N) + (stolb * 3);
                destCoord.Y = row;
                SetConsoleCursorPosition(hStdout, destCoord);
                cout << *(*(arr + row) + stolb) << " ";
                Sleep(50);
            }
        }
    }
    destCoord.X = 0;
    destCoord.Y = N + 1;
    SetConsoleCursorPosition(hStdout, destCoord);
}

void shakerSort(int* arr, int n) {
    bool swapped = true;
    int* start = arr;
    int* end = arr + n * n - 1;

    while (swapped) {
        swapped = false;

        for (int* i = start; i < end; ++i) {
            if (*i > *(i + 1)) {
                swap(*i, *(i + 1));
                swapped = true;
            }
        }

        if (!swapped) {
            break;
        }

        swapped = false;
        --end;

        for (int* i = end - 1; i >= start; --i) {
            if (*i > *(i + 1)) {
                swap(*i, *(i + 1));
                swapped = true;
            }
        }

        ++start;
    }
}
int determinant(int* matrix) {
    return *(matrix) * *(matrix + 4) * *(matrix + 8) + *(matrix + 1) * *(matrix + 5) * *(matrix + 6) + *(matrix + 2) * *(matrix + 3) * *(matrix + 7) -
        (*(matrix + 2) * *(matrix + 4) * *(matrix + 6) + *(matrix) * *(matrix + 7) * *(matrix + 5) + *(matrix + 1) * *(matrix + 3) * *(matrix + 8));
}
int main(int argc, char* argv[])
{
    setlocale(0, "");

    int num;
    cout << "Выберите лабороторную работу: ";
    cin >> num;
    switch (num)
    {
    case 1: {
        //1 ЗАДАНИЕ
        cout << "Программа выводит сколько памяти (в байтах) на вашем компьютере отводится под различные типы данных" << endl;
        cout << "int = " << sizeof(int) << " байта" << endl;
        cout << "short int = " << sizeof(short int) << " байта" << endl;
        cout << "long int = " << sizeof(long int) << " байта" << endl;
        cout << "float = " << sizeof(float) << " байта" << endl;
        cout << "double = " << sizeof(double) << " байта" << endl;
        cout << "long double = " << sizeof(long double) << " байта" << endl;
        cout << "char = " << sizeof(char) << " байта" << endl;
        cout << "bool = " << sizeof(bool) << " байта" << endl;

        cout << endl << endl;

        //2 ЗАДАНИЕ
        {
            cout << "Программа выводит представление десятичного числа типа int в памяти компьютера " << endl;
            int integerNumber;

            cout << "Введите число типа intenger: ";
            cin >> integerNumber;
            cout << "Двоичное представление введенного числа: ";

            unsigned int mask = 1 << (sizeof(int) * 8 - 1);

            for (int i = 1; i < sizeof(int) * 8 + 1; i++, mask >>= 1) {
                if (integerNumber & mask) {
                    cout << "1";
                }
                else {
                    cout << "0";
                }
                if (i == 1 || i % 8 == 0) {
                    cout << " ";
                }
            }
            // ИДЗ 11
            int num;
            int numberBit;
            int integerB;
            cout << endl << "Введите бит для сдвига влево: ";
            cin >> num;
            cout << endl << "Введите насколько сдвинуть бит влево: ";
            cin >> numberBit;
            cout << "Введенное число после сдвига влево на " << numberBit << " бит(а)";


            mask = 1 << (sizeof(int) * 8 - 1);
            for (int i = 1; i < sizeof(int) * 8 + 1; ++i, mask >>= 1) {
                if (mask & integerNumber) {
                    cout << "1";
                }
                else {
                    cout << "0";
                }
                if (i == 1 || i % 8 == 0) {
                    cout << " ";
                }
                if (i == num) {
                    integerB = num << numberBit;
                    integerNumber += integerB;
                }
            }
            cout << endl << "Представление сдвинутого числа в дяситичной системе: " << integerNumber;
        }

        cout << endl << endl;

        //3 ЗАДАНИЕ
        {
            cout << "Программа выводит представление десятичного числа типа float в памяти компьютера " << endl;
            union {
                float floatNumber;
                int integerNumber;
            };
            cout << "Введите число типа float: ";
            cin >> floatNumber;
            cout << "Двоичное представление введенного числа: ";

            unsigned int mask = 1 << (sizeof(int) * 8 - 1);

            for (int i = 1; i < sizeof(int) * 8 + 1; i++, mask >>= 1) {
                if (integerNumber & mask) {
                    cout << "1";
                }
                else {
                    cout << "0";
                }
                if (i == 1 || i % 8 == 0) {
                    cout << " ";
                }
            }
            // ИДЗ 11
            int num;

            cout << endl << "Введите количество битов для сдвига влево: ";
            cin >> num;
            cout << "Введенное число после сдвига влево на " << num << " бит(а)";

            integerNumber = integerNumber << num;
            mask = 1 << (sizeof(int) * 8 - 1);
            for (int i = 1; i < sizeof(int) * 8 + 1; ++i, mask >>= 1) {
                if (mask & integerNumber) {
                    cout << "1";
                }
                else {
                    cout << "0";
                }
                if (i == 1 || i % 8 == 0) {
                    cout << " ";
                }
            }
            cout << endl << "Представление сдвинутого числа в дяситичной системе: " << floatNumber;
        }


        cout << endl << endl;

        // 4 ЗАДАНИЕ
        {
            cout << "Программа выводит представление десятичного числа типа double в памяти компьютера " << endl;
            union {

                double doubleNumber;
                unsigned int sDouble[2];

            };
            cout << "Введите число типа double: ";
            cin >> doubleNumber;
            cout << "Двоичное представление введенного числа: ";

            unsigned int mask = 1 << (sizeof(int) * 8 - 1);
            for (int n = 1; n >= 0; --n) {
                for (int i = 1; i < sizeof(int) * 8 + 1; i++, mask >>= 1) {
                    if (mask & sDouble[n]) {
                        cout << '1';
                    }
                    else {
                        cout << '0';
                    }
                    if (i == 1 && n == 1) {
                        cout << " ";
                    }
                    if (i == 11 && n == 1) {
                        cout << " ";
                    }
                }
                mask = 1 << (sizeof(int) * 8 - 1);
            }
            // ИДЗ 11
            int num;

            cout << endl << "Введите количество битов для сдвига влево: ";
            cin >> num;
            cout << "Введенное число после сдвига влево на " << num << " бит(а)";

            for (int n = 1; n >= 0; --n) {
                sDouble[n] = sDouble[n] << num;
                mask = 1 << (sizeof(int) * 8 - 1);
                for (int i = 1; i < sizeof(int) * 8 + 1; ++i, mask >>= 1) {
                    if (mask & sDouble[n])
                        cout << "1";
                    else
                        cout << "0";
                    if (i == 1 && n == 1) {
                        cout << " ";
                    }
                    if (i == 11 && n == 1) {
                        cout << " ";
                    }
                }
            }
            cout << endl << "Представление сдвинутого числа в дяситичной системе: " << doubleNumber;
        }
    }
          break;
    case 2: {
        while (true) {
            time_point<steady_clock, duration<__int64, ratio<1, 1000000000>>> start1, end1;
            nanoseconds result1;
            setlocale(LC_ALL, "Russian");
            srand(time(0));
            int variant = promptMenuItem();
            const int N(100);
            int arr[N];
            int maxxx(99), minnn(-99), maxEl, minEl, average, middle, k(0), cnt(0), flag(0);
            int maxx(-10000), minn(100000);
            int value, j;
            int end = N - 1, begin = 0;
            int num, count(0);
            for (int i = 0; i < N; i++)
            {
                arr[i] = rand() % (maxxx - minnn + 1) + minnn;
            }
            int size = sizeof(arr) / sizeof(arr[0]);
            int result, random;
            switch (variant) {
            case 1: {
                cout << "Несортированный массив: ";
                for (int i = 0; i < N; i++)
                {
                    cout << arr[i] << " ";
                }
                cout << endl;
            }
                  break;
            case 2: {
                cout << "Несортированный массив: ";
                for (int i = 0; i < N; i++)
                {
                    cout << arr[i] << " ";
                }
                cout << endl;
                auto start1 = steady_clock::now();
                quicksort(arr, end, begin);
                auto end1 = steady_clock::now();
                auto result1 = duration_cast<nanoseconds>(end1 - start1);
                cout << endl << "Отсортированный массив: ";
                for (int i = 0; i < N; i++) {
                    cout << arr[i] << " ";
                }
                cout << endl;
                cout << "Время, затраченное на сортировку массива : " << result1.count() << " nanoseconds" << endl;
            }
                  break;
            case 3: {
                cout << "Несортированный массив: ";
                for (int i = 0; i < N; i++)
                {
                    cout << arr[i] << " ";
                }
                auto start1 = steady_clock::now();
                for (int i = 0; i < N; i++) {
                    if (arr[i] < minn) {
                        minn = arr[i];
                    }
                    if (arr[i] > maxx) {
                        maxx = arr[i];
                    }
                }
                auto end1 = steady_clock::now();
                auto result1 = duration_cast<nanoseconds>(end1 - start1);
                cout << endl;
                cout << endl;
                cout << "Реализация в неотсортированном массиве: \nМаксимальный элемент массива: " << maxx << " и минимальный элемент: " << minn << endl;
                cout << "Время: " << result1.count() << " nanoseconds" << endl;
                quicksort(arr, end, begin);
                auto start = steady_clock::now();
                minEl = arr[0];
                maxEl = arr[99];
                auto end = steady_clock::now();
                auto result = duration_cast<nanoseconds>(end - start);
                cout << "Реализация в отсортированном массиве: \nМаксимальный элемент массива: " << maxEl << " и минимальный элемент: " << minEl << endl;
                cout << "Время: " << result.count() << " nanoseconds" << endl;
            }
                  break;
            case 4: {
                cout << "Несортированный массив: ";
                for (int i = 0; i < N; i++)
                {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                    cout << arr[i] << " ";
                }
                auto start2 = steady_clock::now();
                for (int i = 0; i < N; i++) {
                    if (arr[i] < minn) {
                        minn = arr[i];
                    }
                    if (arr[i] > maxx) {
                        maxx = arr[i];
                    }
                }
                middle = round((maxx - minn) / 2);
                auto end2 = steady_clock::now();
                auto result2 = duration_cast<nanoseconds>(end2 - start2);
                cout << endl;
                cout << "Среднее значение в неотсортированном массиве: " << middle << endl;
                for (int i = 0; i < N; i++) {
                    if (arr[i] == middle) {
                        cout << "На позициии " << i << " находится элемент равный среднему значению " << endl;
                        k += 1;
                    }
                }
                cout << "Количество элементов массива равных среднему значению " << k << " и время поиска " << result2.count() << " nanoseconds" << endl;
                cout << endl;
                quicksort(arr, end, begin);
                auto start1 = steady_clock::now();
                minEl = arr[0];
                maxEl = arr[N - 1];
                average = round((arr[N - 1] - arr[0]) / 2);
                auto end1 = steady_clock::now();
                auto result1 = duration_cast<nanoseconds>(end1 - start1);
                cout << "Среднее значение в отсортированном массиве: " << average << endl;
                for (int i = 0; i < N; i++) {
                    if (arr[i] == average) {
                        cout << "На позициии " << i << " находится элемент равный среднему значению " << endl;
                        cnt += 1;
                    }
                }
                cout << "Количество элементов массива равных среднему значению " << cnt << " и время поиска " << result1.count() << " nanoseconds" << endl;

            }
                  break;

            case 5: {
                cout << "Введите число в промежутке от -99 до 99: " << endl;
                cin >> num;
                for (int i = 0; i < N; i++)
                {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                }
                cout << endl;
                quicksort(arr, end, begin);
                cout << "Отсортированный массив: ";
                for (int i = 0; i < N; i++) {
                    cout << arr[i] << " ";
                    if (num > arr[i]) {
                        count += 1;
                    }
                }
                cout << endl;
                cout << "Количество элементов, которые меньше Вашего числа: " << count << endl;
            }
                  break;

            case 6: {
                cout << "Введите число в промежутке от -99 до 99: " << endl;
                cin >> num;
                for (int i = 0; i < N; i++)
                {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                }
                cout << endl;
                quicksort(arr, end, begin);
                cout << "Отсортированный массив: ";
                for (int i = 0; i < N; i++) {
                    cout << arr[i] << " ";
                    if (num < arr[i]) {
                        count += 1;
                    }
                }
                cout << endl;
                cout << "Количество элементов, которые больше Вашего числа: " << count << endl;
            }
                  break;
            case 7: {
                cout << "Введите каким способом осуществить поиск: бинарный поиск(1) или перебор(2): ";
                cin >> j;
                cout << "Введите число, чтобы проверить есть ли оно в массиве: ";
                cin >> value;
                for (int i = 0; i < N; i++)
                {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                }
                cout << endl;
                if (j == 1) {
                    quicksort(arr, end, begin);
                    cout << endl << "Отсортированный массив: ";
                    for (int i = 0; i < N; i++) {
                        cout << arr[i] << " ";
                    }
                    auto start1 = steady_clock::now();
                    result = binarySearch(arr, value, 0, size - 1);
                    auto end1 = steady_clock::now();
                    auto result1 = duration_cast<nanoseconds>(end1 - start1);
                    cout << endl;
                    if (result == -1) {
                        cout << "Элемент не найден" << endl;
                    }
                    else {
                        cout << "Элемент находится в позиции: " << result + 1 << endl;
                    }
                    cout << "Время, затраченное на нахождения элемента бинарным поиском : " << result1.count() << " nanoseconds" << endl;
                }
                else if (j == 2) {
                    quicksort(arr, end, begin);
                    cout << endl << "Отсортированный массив: ";
                    for (int i = 0; i < N; i++) {
                        cout << arr[i] << " ";
                    }
                    cout << endl;
                    auto start1 = steady_clock::now();
                    for (int m = 0; m < N; m++) {
                        if (arr[m] == value) {
                            cout << "Элемент находится в позиции: " << m << endl;
                            flag += 1;
                            if (arr[m + 1] != value) {
                                break;
                            }
                            else {
                                cout << "2 элемент находится в позиции: " << m + 1 << endl;
                            }

                        }

                    }
                    if (flag == 0) {
                        cout << "Элемент не найден" << endl;
                    }
                    auto end1 = steady_clock::now();
                    auto result1 = duration_cast<nanoseconds>(end1 - start1);
                    cout << "Время, затраченное на нахождения элемента методом перебора : " << result1.count() << " nanoseconds" << endl;
                }
                else {
                    cout << "Вы выбрали неверный вариант" << endl;
                }
            }
                  break;
            case 8: {
                cout << "Введите два числа, которые будут отвечать, какие элементы массива нужно сменить: " << endl;
                cin >> j;
                cin >> num;
                cout << "Несортированный массив: ";
                for (int i = 0; i < N; i++)
                {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                    cout << arr[i] << " ";
                }
                auto start1 = steady_clock::now();
                swap(arr[j], arr[num]);
                auto end1 = steady_clock::now();
                auto result1 = duration_cast<nanoseconds>(end1 - start1);
                cout << endl;
                cout << "Измененный массив: ";
                for (int i = 0; i < N; i++) {
                    cout << arr[i] << " ";
                }
                cout << endl;
                cout << "Время, затраченное на смену местами элементов: " << result1.count() << " nanoseconds" << endl;

            }
                  break;
            case 9: {
                cout << "Несортированный массив: " << endl;
                for (int i = 0; i < N; i++) {
                    arr[i] = rand() % (maxxx - minnn + 1) + minnn;
                    cout << arr[i] << " ";
                }
                size = sizeof(arr) / sizeof(arr[0]);
                auto start1 = steady_clock::now();
                shellSort(arr, size);
                auto end1 = steady_clock::now();
                auto result1 = duration_cast<nanoseconds>(end1 - start1);
                cout << endl;
                cout << "Отсортированный массив: " << endl;
                for (int i = 0; i < N; i++) {
                    cout << arr[i] << " ";
                }
                cout << endl;
                cout << "Время, затраченное на сортировку: " << result1.count() << " nanoseconds" << endl;
                cout << endl;
            }
                  break;
            default:
                cerr << "Вы выбрали неверный вариант" << endl;
                exit(EXIT_FAILURE);
            }

            cout << endl;
        }
        break;
    case 3: {
        srand(time(NULL));
        int maxvalue = N * N, minvalue = 1;
        int arr[N][N];
        int sortArr[N][N];
        int calcArr[N][N];
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                arr[i][j] = rand() % (maxvalue - minvalue + 1) + minvalue;
                sortArr[i][j] = arr[i][j];
                calcArr[i][j] = arr[i][j];
            }
        }
        while (true) {
            setlocale(LC_ALL, "Russian");
            int variant = taskMenu();
            switch (variant) {
            case 1: {
                system("cls");
                ANACONDAoutput2(arr);
                PITONoutput(arr);

            }
                  break;
            case 2: {
                int step = N / 2;
                int abcd;
                cout << "Выберите тип перестановки: " << endl;
                cout << "1) a\n"
                    << "2) b\n"
                    << "3) c\n"
                    << "4) d\n" << endl;
                cin >> abcd;
                switch (abcd) {
                case 1: {
                    system("cls");
                    int change[N][N];
                    int* arr_ptr = *arr;
                    int* change_ptr = *change;
                    for (int i = 0; i < step; i++) {
                        for (int j = 0; j < step; j++) {
                            *(change_ptr + i * N + j) = *(arr_ptr + (i + step) * N + j);
                            *(change_ptr + i * N + (j + step)) = *(arr_ptr + i * N + j);
                            *(change_ptr + (i + step) * N + (j + step)) = *(arr_ptr + i * N + (j + step));
                            *(change_ptr + (i + step) * N + j) = *(arr_ptr + (i + step) * N + (j + step));
                        }
                    }
                    ANACONDAoutput(change);
                    PITONoutput(arr);
                }
                      break;
                case 2: {
                    system("cls");
                    int change2[N][N];
                    int* arr_ptr = *arr;
                    int* change2_ptr = *change2;
                    for (int i = 0; i < step; i++) {
                        for (int j = 0; j < step; j++) {
                            *(change2_ptr + i * N + j) = *(arr_ptr + (i + step) * N + (j + step));
                            *(change2_ptr + i * N + (j + step)) = *(arr_ptr + (i + step) * N + j);
                            *(change2_ptr + (i + step) * N + (j + step)) = *(arr_ptr + i * N + j);
                            *(change2_ptr + (i + step) * N + j) = *(arr_ptr + i * N + (j + step));
                        }
                    }
                    ANACONDAoutput(change2);
                    PITONoutput(arr);
                }
                      break;
                case 3: {
                    system("cls");
                    int change3[N][N];
                    int* arr_ptr = *arr;
                    int* change3_ptr = *change3;
                    for (int i = 0; i < step; i++) {
                        for (int j = 0; j < step; j++) {
                            *(change3_ptr + i * N + j) = *(arr_ptr + (i + step) * N + j);
                            *(change3_ptr + i * N + (j + step)) = *(arr_ptr + (i + step) * N + (j + step));
                            *(change3_ptr + (i + step) * N + j) = *(arr_ptr + i * N + j);
                            *(change3_ptr + (i + step) * N + (j + step)) = *(arr_ptr + i * N + (j + step));
                        }
                    }
                    ANACONDAoutput(change3);
                    PITONoutput(arr);
                }
                      break;
                case 4: {
                    system("cls");
                    int change4[N][N];
                    int* arr_ptr = *arr;
                    int* change4_ptr = *change4;
                    for (int i = 0; i < step; i++) {
                        for (int j = 0; j < step; j++) {
                            *(change4_ptr + i * N + j) = *(arr_ptr + i * N + (j + step));
                            *(change4_ptr + (i + step) * N + j) = *(arr_ptr + (i + step) * N + (j + step));
                            *(change4_ptr + i * N + (j + step)) = *(arr_ptr + i * N + j);
                            *(change4_ptr + (i + step) * N + (j + step)) = *(arr_ptr + (i + step) * N + j);
                        }
                    }
                    ANACONDAoutput(change4);
                    PITONoutput(arr);
                }
                      break;
                }

            }
                  break;
            case 3: {
                system("cls");
                quicksort(*sortArr, *sortArr + N * N);
                ANACONDAoutput(sortArr);
                PITONoutput(arr);
            }
                  break;
            case 4: {
                int matANAL;
                cout << "Выберите тип действия: " << endl;
                cout << "1) Вычитание\n"
                    << "2) Прибавление\n"
                    << "3) Умножение\n"
                    << "4) Деление\n" << endl;
                cin >> matANAL;
                switch (matANAL) {
                case 1: {
                    int num;
                    cout << "Введите число: " << endl;
                    cin >> num;
                    system("cls");
                    int* start = *calcArr;
                    int* end = *(calcArr + N * N - 1);
                    for (int* ptr = start; ptr <= end; ++ptr) {
                        *ptr -= num;
                    }
                    ANACONDAoutput(calcArr);
                    PITONoutput(arr);
                }
                      break;
                case 2: {
                    int num;
                    cout << "Введите число: " << endl;
                    cin >> num;
                    system("cls");
                    int* start = *calcArr;
                    int* end = *(calcArr + N * N - 1);
                    for (int* ptr = start; ptr <= end; ++ptr) {
                        *ptr += num;
                    }
                    ANACONDAoutput(calcArr);
                    PITONoutput(arr);
                }
                      break;
                case 3: {
                    int num;
                    cout << "Введите число: " << endl;
                    cin >> num;
                    system("cls");
                    int* start = *calcArr;
                    int* end = *(calcArr + N * N - 1);
                    for (int* ptr = start; ptr <= end; ++ptr) {
                        *ptr *= num;
                    }
                    ANACONDAoutput(calcArr);
                    PITONoutput(arr);
                }
                      break;
                case 4: {
                    int num;
                    cout << "Введите число: " << endl;
                    cin >> num;
                    system("cls");
                    int* start = *calcArr;
                    int* end = *(calcArr + N * N - 1);
                    for (int* ptr = start; ptr <= end; ++ptr) {
                        *ptr /= num;
                    }
                    ANACONDAoutput(calcArr);
                    PITONoutput(arr);
                }
                      break;
                }
                break;
            }
            case 5: {
                const int N = 3;
                int matrix[N][N];
                srand((time(0)));
                for (int i = 0; i < N; ++i) {
                    for (int j = 0; j < N; ++j) {
                        *(*(matrix + i) + j) = rand() % 61 - 30;
                    }
                }

                cout << "Сгенерированная матрица 3x3:" << endl;
                for (int i = 0; i < N; ++i) {
                    for (int j = 0; j < N; ++j) {
                        *(*(matrix + i) + j) = rand() % 61 - 30;
                        cout << *(*(matrix + i) + j) << '\t';
                    }
                    cout << endl;
                }
                int det = determinant(&matrix[0][0]);
                cout << "Определитель матрицы: " << det << endl;
            }
                  break;
            }

        }
        
    }
    break;
    case 4: {
        char inputText[1000];
        const int MAX_LENGTH = 1000;
        char words[MAX_LENGTH][MAX_LENGTH];
        int wordCount = 0;
        while (true) {
            cout << "Введите с клавиатуры(1) или с файла(2), или 0 для выхода: ";
            int choice;
            cin >> choice;
            cin.ignore();

            if (choice == 0) {
                break;
            }

            if (choice == 1) {
                cout << "Введите текст (может не заканчиваться точкой):\n";
                cin.getline(inputText, sizeof(inputText));
            }
            else if (choice == 2) {
                char fileName[100];
                cout << "Введите имя файла:\n";
                cin.getline(fileName, sizeof(fileName));

                ifstream inputFile(fileName);
                if (!inputFile.is_open()) {
                    cerr << "Ошибка открытия файла!" << endl;
                    continue;
                }

                inputFile.getline(inputText, sizeof(inputText));
                inputFile.close();
                cout << "Текст из файла: " << inputText << endl;
            }
            else {
                cerr << "Неверный выбор!" << endl;
                continue;
            }

            editText(inputText);
            cout << "Отредактированный текст: " << inputText << endl;
            char* token = strtok(inputText, " ");
            while (token != nullptr) {
                strcpy(words[wordCount++], token);
                token = strtok(nullptr, " ");
            }
            cout << "Слова в обратном порядке: ";
            for (int i = wordCount - 1; i >= 0; --i) {
                cout << words[i] << ' ';
            }
            cout << endl;
            cout << "Количество символов в каждом слове:" << endl;
            for (int i = 0; i < wordCount; ++i) {
                cout << words[i] << ": " << strlen(words[i]) << " символов" << endl;
            }
            char text[MAX_LENGTH];
            char pattern[MAX_LENGTH];

            cout << "Введите строку: ";
            cin.getline(text, MAX_LENGTH);
            cout << "Введите подстроку для поиска: ";
            cin.getline(pattern, MAX_LENGTH);
            cout << "Результаты линейного поиска:" << endl;
            linearSearch(text, pattern);
            cout << "Введите строку: ";
            cin.getline(text, MAX_LENGTH);
            cout << "Введите подстроку для поиска: ";
            cin.getline(pattern, MAX_LENGTH);
            cout << "Результаты алгоритма Бойера-Мура:" << endl;
            boyerMooreSearch(text, pattern);

        }
    }
          break;
    default:
        break;
    }



    }
}
